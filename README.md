# java-explore-with-me

## Технологии: Java 11, Spring Boot, Spring Data JPA, PostgreSQL, Docker.

API сервис - афиша, для оповещения друзей о различных событиях. Сервис позволяет не только оповестить друзей, но и
собрать их вместе в условленное время. Построен с использованием, микросервисной архитектуры, Postgresql и Docker.

### Микросервисная архитектура

Приложение состоит из 2 сервисов:
ewm-service - основная часть приложения, в которой реализуется логика приложения.
stats-service - часть сбора и хранения статистики по просмотрам.

### Жизненный цикл события:

1. В приложении есть три формы аутентификации: обычная общедоступная – через которую любой пользователь может
   просматривать события, приватная – в которой пользователь может создавать и редактировать собственные события,
   административная – с помощью которой администратор принимает решения о публикации
2. Создание события. Автор указывает дату, местоположение, категорию, описание, стоимость, лимит участников события и
   необходимость модерации.
3. После создания, событие находится в состоянии ожидания публикации.
4. Администратор переводит событие в состояние публикации и оно становится доступным для пользователей.
5. Отмена публикации возможна в двух случаях: 1. администратор решил, что оно не должно быть опубликовано. 2. инициатор
   события решил отменить его на стадии ожидания публикации.
6. Пользователи могут просматривать список событий, фильтровать их по категориям, дате, местоположению и другим
   параметрам.
7. Пользователи могут подавать заявки на участие в событиях, которые могут быть подвергнуты модерации.
8. Организаторы событий могут одобрять или отклонять заявки на участие.
9. Администраторы могут создавать тематические подборки событий и закреплять их на видном месте.
10. Пользователи могут оставлять комментарии к событиям.
11. Пользователи имеют возможность поиска событий поблизости
    Основной сервис и сервис статистики сохраняют и загружают данные из разных баз данных. Взаимодействие сервисов в
    момент сохранения информации о запросе к API осуществляется с помощью клиента сервиса статистики

### Установка и запуск проекта

Приложение использует Docker для своей работы. Для запуска приложения, потребуется скачать его из текущего репозитория и
запустить сборку проекта на своей машине из командной строки.
После ввода команды: $ docker-compose up, приложение запустится на порту 8080.

### Приложение ewm-имеет следующие разделы:

* category
* comments
* compilation
* event
* location
* request
* user
* exceptions
* validation

### user

Модель User имеет следующие поля:

Id – уникальный идентификатор, name – имя, email – емейл.

Пользователей может добавлять администратор, поэтому контроллер доступен для администратора:

#### AdminUserController

В контроллере представлены стандартные запросы:

* GET /users - Возвращает список пользователей, начиная с записи 0, по 10 пользователей на странице.
* GET /users?from=5&size=20 - Возвращает список пользователей, начиная с записи 5, по 20 пользователей на странице.
* GET /users?ids=1,2,3&from=5&size=20 - Возвращает список пользователей с идентификаторами 1, 2 и 3, начиная с записи 5,
  по 20 пользователей на странице.
* POST /users
* DELETE /users/{userId}

Обращения к БД в разделе user не выходит за рамки стандартных операций, реализуемых с помощью интерфейса Spring Data
JPA.

### event

Модель Event имеет следующие поля:

id – уникальный идентификатор, initiator – автор события, annotation – краткое описание события, category – категория,
description – полное описание события, eventDate – дата события, location – место события, paid – указатель платное или
бесплатное событие, participantLimit – максимальное количество участников, requestModeration – указывает на
необходимость модерации, title – заголовок события, state – текущее состояние события, publishedOn – дата публикации,
createdOn – дата создания.

В данном разделе находятся три контроллера:

#### AdminEventController

Контроллер предоставляет административный интерфейс для управления событиями, позволяя получать список событий с
фильтрацией и частично обновлять существующие события.

* GET /admin/events - Получает все события (отфильтрованные по умолчанию, если AdminGetEventParams имеет значения по
  умолчанию).
* GET /admin/events?users=..&states=…&categories=…&rangeStart=…&rangeEnd=…&from=…&size=…
* PATCH /admin/events/{eventId}: Частичное обновление существующего события.

#### PrivateEventController

Контроллер предоставляет набор API пользователю для управления собственными событиями, включая создание, просмотр,
обновление и управление заявками на участие.

* GET /users/{userId}/events: Получение списка событий, созданных пользователем.
* GET /users/{userId}/events/{eventId}: Получение информации о конкретном событии пользователя.
* POST /users/{userId}/events: Создание нового события для пользователя.
* PATCH /users/{userId}/events/{eventId}: Частичное обновление существующего события пользователя.
* GET /users/{userId}/events/{eventId}/requests: Получение списка заявок на участие в событии.
* PATCH /users/{userId}/events/{eventId}/requests: Обновление статуса заявок на участие в событии.

#### PublicEventController

Контроллер предназначен для публичного доступа, то есть любой пользователь может получить информацию о событиях

* GET /events:  Получение списка событий с возможностью фильтрации.
* GET /events/{id}:  Получение информации о конкретном событии по его ID.

Обращения к БД в разделе event расширяют рамки стандартных операций, реализуемых с помощью интерфейса Spring Data JPA.
Примеры запросов к БД:

    @Query("""
    select event FROM Event event WHERE (:users IS NULL
    OR event.initiator.id IN :users) AND (:states IS NULL
    OR event.state IN :states) AND (:categories IS NULL
    OR event.category.id IN :categories) AND (event.eventDate >= :rangeStart)

### request

Модель Request имеет следующие поля:
id – уникальный идентификатор, created – дата создания запроса, event – событие, requester – пользователь, status –
статус запроса

#### PrivateRequestController

Контроллер предоставляет API для управления заявками на участие в событиях, созданными конкретным пользователем. Включая
создание и отмену заявок. Все запросы привязаны к userId.

* GET /users/{userId}/requests: Получение списка заявок на участие в событиях, созданных пользователем.
* POST /users/{userId}/requests: Создание новой заявки на участие в событии для пользователя.
* PATCH /users/{userId}/requests/{requestId}/cancel: Отмена заявки на участие в событии.

Помимо стандартных методов, репозиторий содержит набор кастомных методов для выполнения специфических запросов к базе
данных, связанных с сущностями Request.

Например:

    List<Request> findAllByRequesterId(Long userId);:

Находит все заявки (Request) в базе данных, связанные с определенным пользователем (requesterId).

    List<Request> findAllByStatusAndEventIdIn(Status status, List<Long> eventsIds);:

Находит все заявки (Request) с определенным статусом (status) для списка событий (eventsIds).

### category

Модель Category содержит два поля id и name.

#### AdminCategoryController

Контроллер, предназначен для административного управления категориями событий. Он предоставляет API для создания,
удаления и обновления категорий.

* POST /admin/categories: Создание новой категории.
* DELETE /admin/categories/{catId}: Удаление категории.
* PATCH /admin/categories/{catId}: Частичное обновление существующей категории.

Репозиторий, помимо стандартных методов JpaRepository, содержит один кастомный метод:

    Optional<Object> findByName(String name);:

Находит категорию в базе данных по ее имени (name).

### comments

Модель Comment содержит следующие поля:
id – уникальный идентификатор, text – текст комментария, author – автор комментария, event – событие, created – дата
создания

В данном разделе также три контроллера:

#### CommentAdminController:

Административный API для удаления комментария по id:

DELETE /admin/comments/{commentId}

#### CommentPrivateController:

Контроллер, предоставляющий пользователю API для управления его комментариями, к конкретным событиям. Контроллер
предоставляет возможность создавать, обновлять, получать и удалять комментарии.

* POST /users/{userId}/comments/events/{eventId} - Создает новый комментарий для указанного события от лица указанного
  пользователя.
  Тело запроса: CommentDto (JSON, содержащий текст комментария и, возможно, другие данные).
  Успешный ответ (201 Created): Комментарий успешно создан. Возвращает CommentShortDto с информацией о созданном
  комментарии.

* PATCH /users/{userId}/comments/{commentId} - Обновляет существующий комментарий с указанным идентификатором от лица
  указанного пользователя.
  Тело запроса: CommentDto
  Успешный ответ (200 OK): Комментарий успешно обновлен. Возвращает CommentShortDto с информацией об обновленном
  комментарии.

* GET /users/{userId}/comments/events/{eventId} - Получает список всех комментариев для указанного события от лица
  указанного пользователя.
  Возвращает список объектов CommentShortDto в формате JSON, представляющих комментарии для указанного события. Если
  комментариев нет, возвращается пустой список.
  Успешный ответ (200 OK): Возвращает список объектов CommentShortDto в формате JSON, представляющих комментарии для
  указанного события. Если комментариев нет, возвращается пустой список.

* DELETE /users/{userId}/comments/{commentId} - Удаляет комментарий с указанным идентификатором от лица указанного
  пользователя.
  Успешный ответ (204 No Content): Комментарий успешно удален. Тело ответа пустое.

#### CommentPublicController

CommentPublicController - это REST-контроллер, предоставляющий публичный API для получения информации о комментариях. Он
предоставляет методы для получения комментария по идентификатору, списка комментариев для определенного события и списка
комментариев, написанных определенным пользователем.

* GET /comments/{commentId} - Получает комментарий по его идентификатору.
  Успешный ответ (200 OK): Комментарий найден. Возвращает CommentFullDto в формате JSON.

* GET /comments/events/{eventId}?from={from}&size={size}&sort={sort}
  Получает список комментариев для указанного события с поддержкой пагинации и сортировки.
  Успешный ответ (200 OK): Возвращает список объектов CommentFullDto в формате JSON, представляющих комментарии для
  указанного события. Если комментариев нет, возвращается пустой список.

* GET /comments/users/{userId}?from={from}&size={size}&sort={sort}
  Получает список комментариев, написанных указанным пользователем, с поддержкой пагинации и сортировки.
  Успешный ответ (200 OK): Возвращает список объектов CommentShortDto в формате JSON, представляющих комментарии,
  написанные указанным пользователем. Если комментариев нет, возвращается пустой список.

CommentRepository - это интерфейс, представляющий репозиторий для работы с сущностью Comment в базе данных. Он расширяет
интерфейс JpaRepository из Spring Data JPA, предоставляя стандартные CRUD-операции (Create, Read, Update, Delete) и
методы для работы с пагинацией и сортировкой. Кроме того, он определяет пользовательские методы запросов для
специфических нужд приложения.

Примеры пользовательских методов:

    findByAuthorIdAndEventId(long userId, long eventId);

Описание:  Возвращает список всех комментариев, написанных пользователем с ID userId для события с ID eventId.

### compilation

Модель Compilation содержит поля: id – уникальный идентификатор, title – заголовок, pinned – поле указывающее,
закреплена ли подборка, events – список событий.

Раздел включает два контроллера:

#### AdminCompilationController - контроллер, предоставляющий API для административного управления подборками (compilations). Позволяет администратору создавать, удалять и обновлять подборки.

* POST /admin/compilations
  Описание: Создает новую подборку.
  Успешный ответ (201 Created): Подборка успешно создана. Возвращает CompilationDto с информацией о созданной подборке.

* DELETE /admin/compilations/{compId}
  Успешный ответ (204 No Content): Подборка успешно удалена. Тело ответа пустое.

* PATCH /admin/compilations/{compId}
  Описание: Обновляет существующую подборку с указанным идентификатором.
  спешный ответ (200 OK): Подборка успешно обновлена. Возвращает CompilationDto с информацией об обновленной подборке.

#### PublicCompilationController

контроллер, предоставляющий публичный API для получения информации о подборках (compilations). Он позволяет
пользователям получить список подборок с возможностью фильтрации по признаку закрепления (pinned) и постраничного
вывода, а также получить информацию о конкретной подборке по её идентификатору.

* GET /compilations?pinned={pinned}&from={from}&size={size}
  Получает список подборок с возможностью фильтрации по признаку закрепления и с поддержкой пагинации.
  pinned (optional): Фильтр по признаку закрепления. Может быть true (только закрепленные подборки), false (только
  незакрепленные подборки) или отсутствовать (все подборки). Тип Boolean.
  Успешный ответ (200 OK): Возвращает список объектов CompilationDto в формате JSON, представляющих подборки,
  соответствующие критериям. Если подборки не найдены, возвращается пустой список.

* GET /compilations/{compId}
  Получает информацию о подборке по её идентификатору.
  Успешный ответ (200 OK): Подборка найдена. Возвращает объект CompilationDto в формате JSON, представляющий подборку.

#### CompilationRepository

Репозиторий предоставляет доступ к сущностям Compilation в базе данных. Он позволяет:

* Использовать стандартные операции CRUD, предоставляемые JpaRepository.
* Выполнять поиск подборок с поддержкой пагинации, фильтруя их по значению флага pinned (закреплена или нет). С
  использованием JPQL. При этом, возможность не фильтровать по pinned (передав null в качестве параметра) делает метод
  более универсальным....

### location

Этот раздел предназначен для доступа и управления данными, представляющими географические местоположения, которые
представлены в виде сущности Location.
Полями сущности являются: id – уникальный идентификатор, lat – координата широты, lon – координата долготы.

#### LocationRepositor

Представляет собой простой, компонент для работы с данными.
Позволяет выполнять стандартные операции CRUD (Create, Read, Update, Delete) над этими данными. Обращение к нему
осуществляется через EventServiceImpl.

Кроме того, в разделах exceptions и validation сгруппированы исключения и валидация передаваемых данных.

### stats-service

Представляет собой сервис статистики. Он включает три подраздела:
stats-client, stats-dto и stats-server

#### stats-client

Представляет собой клиент для взаимодействия со "Stats Server". Он предоставляет методы для:

Отправки информации о "хитах" (событиях) на сервер статистики (метод postHit). Это позволяет регистрировать, посещения
веб-страниц, клики по кнопкам и другие действия пользователя.
Получения статистики с сервера статистики (метод getStats). Статистика включает количество просмотров определенного URI
за определенный период времени.

#### stats-dto

играет роль контейнера данных, который передается между разными частями приложения, в данном случае, между клиентом (
StatsClient) и сервером статистики. Аббревиатура DTO расшифровывается как Data Transfer Object. (Объект передачи
данных).

stats-dto определяет, какие данные будут отправляться и получаться между StatsClient и сервером статистики. Он задает
поля (атрибуты), которые будут сериализованы (преобразованы в JSON) при отправке запроса и десериализованы (
преобразованы из JSON) при получении ответа.
EndpointHitDto: Используется для отправки информации о "хите" на сервер статистики. Определяет, какие поля должны быть
включены в POST-запрос к endpoint /hit.
ViewStatsDto определяет, какие поля содержит статистика о просмотрах (URI, app, hits и т.д.).

#### stats-server

EndpointHit

Класс EndpointHit представляет собой модель данных для хранения информации о событиях (хитах), связанных с запросами к
endpoint'ам приложения. EndpointHit представляет собой JPA-сущность, которая отображается на таблицу endpoint_hits в
базе данных. Каждая запись в таблице endpoint_hits соответствует одному "хиту" и содержит информацию о приложении, URI,
IP-а.

Модель содержит поля: id – уникальный идентификатор, uri - поле представляет собой URI запрошенного эндпойнта, ip –
ip-адрес пользователя сделавшего запрос, timestamp – дата и время «хита».

stats-controller

REST-контроллер, который предоставляет два endpoint'а: /hit для сохранения информации о "хитах" и /stats для получения
статистики о просмотрах.

    public EndpointHitDto saveStatHit 

Это метод, который обрабатывает POST-запросы на /hit.

    return statsService.saveStatsHit(endpointHit)

Вызывает метод saveStatsHit сервиса StatsService, передавая ему объект EndpointHitDto. Этот метод передает информацию
о "хите" в сервис и оттуда в базу данных. Возвращает объект EndpointHitDto.

    public List<ViewStatsDto> getVeiwStats(...)

Это метод, который обрабатывает GET-запросы на /stats.

    return statsService.getViewStats(startTime, endTime, uris, unique):  Вызывает метод getViewStats сервиса StatsService, передавая ему распарсенные значения startTime и endTime, а также параметры uris и unique.  Предполагается, что этот метод получает статистику о просмотрах и возвращает список объектов ViewStatsDto.

#### StatsRepository

Это JPA-репозиторий, который предоставляет методы для запроса статистики из таблицы endpoint_hits (на которую
отображается сущность EndpointHit). Помимо стандартных, тут используется JPQL для выполнения сложных запросов.

Примеры методов:

    @Query
    ("""
    select new ru.practicum.ViewStatsDto(e.app, e.uri, count(distinct e.ip))
    from EndpointHit as e where e.timestamp >= :startTime and e.timestamp <= :endTime
    group by e.app, e.uri order by count(e.ip) desc
    """)
    List<ViewStatsDto> getUniqueStatsWithoutUris(
    @Param("startTime") LocalDateTime startTime,
    @Param("endTime") LocalDateTime endTime);

Данный запрос возвращает статистику уникальных просмотров для всех URI в базе данных, которые попадают в указанный
временной диапазон.